D:\Humans\classmate\server\api\src\workflows\summarize-class\README.md
```markdown
# Summarize Class Workflow

This workflow processes audio or text files to generate class summaries using AI (Google Gemini).

## Architecture

The workflow follows the project's hexagonal architecture:

```
src/workflows/summarize-class/
‚îú‚îÄ‚îÄ index.ts              # Workflow entrypoint (WorkflowEntrypoint)
‚îú‚îÄ‚îÄ handler.ts            # Workflow logic (orchestration)
‚îú‚îÄ‚îÄ dependencies.ts       # Dependency injection
‚îú‚îÄ‚îÄ types.ts              # Workflow-specific types
‚îî‚îÄ‚îÄ file-validator.ts     # File validation utilities
```

## Processing Flow

### 1. Trigger (HTTP Endpoint)
**Endpoint:** `POST /classes/:classId/process-audio`

**Request Body:**
```json
{
  "r2_key": "temp/user123/audio-file.mp3",
  "file_name": "audio-file.mp3",
  "mime_type": "audio/mpeg"
}
```

**Response (202 Accepted):**
```json
{
  "success": true,
  "result": {
    "workflow_instance_id": "workflow-abc123",
    "status": "accepted"
  }
}
```

### 2. Workflow Steps

The workflow executes three main steps:

#### Step 1: Generate Summary
- **Timeout:** 30 minutes
- **Retries:** 3 attempts with exponential backoff
- **Actions:**
  1. Download file from R2 using `r2_key`
  2. Load prompt template
  3. Determine if audio or text
  4. Send content to Google Gemini to generate Markdown summary

#### Step 2: Save Summary
- **Timeout:** 10 minutes
- **Retries:** 5 attempts with exponential backoff
- **Actions:**
  1. Convert Markdown to HTML using MiniGFM (XSS-safe)
  2. Save HTML to `summary` column in `classes` table

#### Step 3: Cleanup
- **Timeout:** 5 minutes
- **Actions:**
  1. Delete temporary file from R2 bucket

## Used Services

### Domain Services (Ports)
- `AIService` - AI services interface
- `PromptService` - Prompt loading interface
- `StorageService` - File storage interface
- `MarkdownService` - Markdown‚ÜíHTML conversion interface

### Infrastructure (Adapters)
- `GoogleAIService` - Google Gemini implementation
- `AssetsPromptService` - Prompt loading from assets
- `R2StorageService` - Cloudflare R2 storage via S3 SDK
- `MiniGFMMarkdownService` - Markdown‚ÜíHTML conversion with sanitization
- `D1SummaryRepository` - Persistence in D1 Database

## Configuration

### Required Environment Variables

Configured in Cloudflare Secrets Store:
- `GEMINI_API_KEY` - Google Gemini API key
- `R2_S3_API_ENDPOINT` - R2 S3-compatible endpoint
- `R2_ACCESS_KEY_ID` - R2 access key
- `R2_SECRET_ACCESS_KEY` - R2 secret key
- `R2_TEMPORAL_BUCKET_NAME` - Temporary bucket name

### Workflow Binding

In `wrangler.jsonc`:
```json
{
  "workflows": [
    {
      "name": "summarize-class",
      "binding": "SUMMARIZE_CLASS_WORKFLOW",
      "class_name": "SummarizeClassWorkflow"
    }
  ]
}
```

## Endpoint Usage

### 1. Generate Upload URL
```bash
POST /classes/{classId}/generate-upload-url
{
  "file_name": "my-lecture.mp3",
  "content_type": "audio/mpeg"
}
```

Response:
```json
{
  "success": true,
  "result": {
    "signed_url": "https://...",
    "key": "temp/user123/my-lecture.mp3"
  }
}
```

### 2. Upload File to R2
```bash
PUT {signed_url}
Content-Type: audio/mpeg
Body: [binary file]
```

### 3. Process File
```bash
POST /classes/{classId}/process-audio
{
  "r2_key": "temp/user123/my-lecture.mp3",
  "file_name": "my-lecture.mp3",
  "mime_type": "audio/mpeg"
}
```

Response:
```json
{
  "success": true,
  "result": {
    "workflow_instance_id": "workflow-abc123",
    "status": "accepted"
  }
}
```

### 4. Check Summary
```bash
GET /classes/{classId}
```

The `summary` field will contain the generated HTML when the workflow completes.

## Supported File Types

### Audio
- MP3 (`audio/mpeg`)
- WAV (`audio/wav`)
- OGG (`audio/ogg`)
- FLAC (`audio/flac`)
- M4A (`audio/m4a`)
- AAC (`audio/aac`)
- Other audio formats

### Text
- TXT (`text/plain`)
- Markdown (`text/markdown`)

## Error Handling

The workflow implements automatic retries per step:
- R2 network errors ‚Üí exponential retries
- AI errors (Gemini) ‚Üí 3 retries
- Database errors ‚Üí 5 retries

If all retries fail, the workflow is marked as failed and logs the error.

## Monitoring

Generated logs:
- `[WORKFLOW]` - Workflow start and end
- `[R2_STORAGE]` - Download/delete operations
- `[AI]` - Gemini processing
- `[SUMMARY_REPO]` - Database saving

## Local Development

### Prerequisites
```bash
# Install dependencies
bun install

# Configure local secrets
echo "GEMINI_API_KEY=your_key" >> .dev.vars
echo "R2_S3_API_ENDPOINT=https://..." >> .dev.vars
# ... other secrets
```

### Run in Dev Mode
```bash
bun run dev
```

The workflow will be available but uses Cloudflare Workflows in local mode.

## Testing

Unit tests in:
- `src/application/classes/generate-class-audio-upload-url.usecase.test.ts`
- Future workflow handler tests can be added in `src/workflows/summarize-class/`

## Future Improvements

- [ ] Support more file formats (PDF, DOCX)
- [ ] Add webhooks to notify when processing ends
- [ ] Implement endpoint to query workflow status
- [ ] Add metrics and tracing with Cloudflare Analytics
- [ ] Implement user rate limits

```

D:\Humans\classmate\server\api\src\workflows\summarize-class\dependencies.ts
```typescript
import type { Bindings } from "../../config/bindings";
import { resolveSecretBinding } from "../../config/bindings";
import { GoogleAIService } from "../../infrastructure/ai/google.ai.service";
import { DatabaseFactory } from "../../infrastructure/database/client";
import { D1SummaryRepository } from "../../infrastructure/database/repositories/summary.repository";
import { MiniGFMMarkdownService } from "../../infrastructure/markdown/minigfm.markdown.service";
import { CloudRunProcessingService } from "../../infrastructure/processing/cloud-run.processing.service";
import { AssetsPromptService } from "../../infrastructure/prompt/assets.prompt.service";
import { R2StorageAdapter } from "../../infrastructure/storage/r2.storage";
import { R2StorageService } from "../../infrastructure/storage/r2.storage.service";
import { SummarizeClassWorkflowHandler } from "./handler";

/**
 * Dependency Injection Factory
 * Creates and wires up all services and repositories for the workflow
 */
export async function createSummarizeClassWorkflowHandler(
	env: Bindings,
): Promise<SummarizeClassWorkflowHandler> {
	// Resolve secrets
	const geminiApiKey = await resolveSecretBinding(
		env.GEMINI_API_KEY,
		"GEMINI_API_KEY",
	);
	const r2Endpoint = await resolveSecretBinding(
		env.R2_S3_API_ENDPOINT,
		"R2_S3_API_ENDPOINT",
	);
	const r2AccessKeyId = await resolveSecretBinding(
		env.R2_ACCESS_KEY_ID,
		"R2_ACCESS_KEY_ID",
	);
	const r2SecretAccessKey = await resolveSecretBinding(
		env.R2_SECRET_ACCESS_KEY,
		"R2_SECRET_ACCESS_KEY",
	);
	const r2BucketName = await resolveSecretBinding(
		env.R2_TEMPORAL_BUCKET_NAME,
		"R2_TEMPORAL_BUCKET_NAME",
	);

	// Create infrastructure services
	const processingService = new CloudRunProcessingService(env);
	const aiService = new GoogleAIService(geminiApiKey);
	const promptService = new AssetsPromptService(env.ASSETS);
	const storageService = new R2StorageService({
		endpoint: r2Endpoint,
		accessKeyId: r2AccessKeyId,
		secretAccessKey: r2SecretAccessKey,
		bucketName: r2BucketName,
	});
	const markdownService = new MiniGFMMarkdownService();

	// Create storage adapter for generating presigned URLs
	const storageRepository = new R2StorageAdapter({
		endpoint: r2Endpoint,
		accessKeyId: r2AccessKeyId,
		secretAccessKey: r2SecretAccessKey,
	});

	// Create database connection and repository
	const db = DatabaseFactory.create(env.DB);
	const summaryRepository = new D1SummaryRepository(db);

	// Wire up and return handler
	return new SummarizeClassWorkflowHandler(
		processingService,
		aiService,
		storageService,
		storageRepository,
		summaryRepository,
		markdownService,
		promptService,
		r2BucketName,
	);
}

```

D:\Humans\classmate\server\api\src\workflows\summarize-class\file-validator.test.ts
```typescript
import { describe, expect, it } from "vitest";
import { FileValidator } from "./file-validator";

describe("FileValidator", () => {
	const validator = new FileValidator();

	describe("isAudioFile", () => {
		it("should return true for audio MIME types", () => {
			expect(validator.isAudioFile("audio/mpeg", "file.mp3")).toBe(true);
			expect(validator.isAudioFile("audio/wav", "file.wav")).toBe(true);
			expect(validator.isAudioFile("audio/ogg", "file.ogg")).toBe(true);
			expect(validator.isAudioFile("audio/flac", "file.flac")).toBe(true);
		});

		it("should return false for non-audio MIME types", () => {
			expect(validator.isAudioFile("text/plain", "file.txt")).toBe(false);
			expect(validator.isAudioFile("text/markdown", "file.md")).toBe(false);
			expect(validator.isAudioFile("application/pdf", "file.pdf")).toBe(false);
		});

		it("should detect audio from extension when MIME is octet-stream", () => {
			expect(
				validator.isAudioFile("application/octet-stream", "file.mp3"),
			).toBe(true);
			expect(
				validator.isAudioFile("application/octet-stream", "file.wav"),
			).toBe(true);
			expect(
				validator.isAudioFile("application/octet-stream", "file.txt"),
			).toBe(false);
		});

		it("should be case-insensitive for extensions", () => {
			expect(
				validator.isAudioFile("application/octet-stream", "file.MP3"),
			).toBe(true);
			expect(
				validator.isAudioFile("application/octet-stream", "file.WaV"),
			).toBe(true);
		});
	});

	describe("getAudioMimeType", () => {
		it("should return MIME type for audio files", () => {
			expect(validator.getAudioMimeType("audio/mpeg", "file.mp3")).toBe(
				"audio/mpeg",
			);
			expect(validator.getAudioMimeType("audio/wav", "file.wav")).toBe(
				"audio/wav",
			);
		});

		it("should return undefined for non-audio files", () => {
			expect(
				validator.getAudioMimeType("text/plain", "file.txt"),
			).toBeUndefined();
			expect(
				validator.getAudioMimeType("application/pdf", "file.pdf"),
			).toBeUndefined();
		});

		it("should detect and return MIME type from extension when octet-stream", () => {
			expect(
				validator.getAudioMimeType("application/octet-stream", "file.mp3"),
			).toBe("audio/mpeg");
			expect(
				validator.getAudioMimeType("application/octet-stream", "file.wav"),
			).toBe("audio/wav");
			expect(
				validator.getAudioMimeType("application/octet-stream", "file.m4a"),
			).toBe("audio/m4a");
		});

		it("should prefer provided MIME type over extension detection", () => {
			// If MIME type is already audio/*, use it
			expect(validator.getAudioMimeType("audio/mpeg", "file.wav")).toBe(
				"audio/mpeg",
			);
		});
	});
});

```

D:\Humans\classmate\server\api\src\workflows\summarize-class\file-validator.ts
```typescript
/**
 * File Validator Service
 * Provides utilities for file type detection and validation
 */

const MIME_TYPE_MAP: Record<string, string> = {
	// Audio formats
	mp3: "audio/mpeg",
	wav: "audio/wav",
	ogg: "audio/ogg",
	flac: "audio/flac",
	m4a: "audio/m4a",
	aac: "audio/aac",
	wma: "audio/wma",
	mka: "audio/matroska",
	// Text formats
	txt: "text/plain",
	md: "text/markdown",
	markdown: "text/markdown",
};

export class FileValidator {
	isAudioFile(mimeType: string, filename: string): boolean {
		const detectedMimeType =
			mimeType === "application/octet-stream"
				? this.getMimeTypeFromExtension(filename)
				: mimeType;
		return (
			mimeType.startsWith("audio/") || detectedMimeType.startsWith("audio/")
		);
	}

	getAudioMimeType(mimeType: string, filename: string): string | undefined {
		const isAudioFile = this.isAudioFile(mimeType, filename);
		const detectedMimeType =
			mimeType === "application/octet-stream"
				? this.getMimeTypeFromExtension(filename)
				: mimeType;

		if (isAudioFile) {
			return mimeType.startsWith("audio/") ? mimeType : detectedMimeType;
		}
		return undefined;
	}

	private getMimeTypeFromExtension(filename: string): string {
		const ext = filename.toLowerCase().split(".").pop();
		return MIME_TYPE_MAP[ext || ""] || "application/octet-stream";
	}
}

```

D:\Humans\classmate\server\api\src\workflows\summarize-class\handler.test.ts
```typescript
import type { WorkflowEvent, WorkflowStep } from "cloudflare:workers";
import { beforeEach, describe, expect, it, vi } from "vitest";
import type { StorageRepository } from "../../domain/repositories/storage.repository";
import type { SummaryRepository } from "../../domain/repositories/summary.repository";
import type { AIService } from "../../domain/services/ai.service";
import type { MarkdownService } from "../../domain/services/markdown.service";
import type { ProcessingService } from "../../domain/services/processing.service";
import type { PromptService } from "../../domain/services/prompt.service";
import type { StorageService } from "../../domain/services/storage.service";
import { SummarizeClassWorkflowHandler } from "./handler";
import type { WorkflowRequestBody } from "./types";

describe("SummarizeClassWorkflowHandler", () => {
	let handler: SummarizeClassWorkflowHandler;
	let mockProcessingService: ProcessingService;
	let mockAIService: AIService;
	let mockStorageService: StorageService;
	let mockStorageRepository: StorageRepository;
	let mockSummaryRepository: SummaryRepository;
	let mockMarkdownService: MarkdownService;
	let mockPromptService: PromptService;
	let mockStep: WorkflowStep;

	beforeEach(() => {
		// Create mocks
		mockProcessingService = {
			processUrl: vi.fn(),
		};

		mockAIService = {
			generateContent: vi.fn(),
			generateSummaryFromUrl: vi.fn(),
		};

		mockStorageService = {
			getFileBytes: vi.fn(),
			deleteFile: vi.fn(),
		};

		mockStorageRepository = {
			generatePresignedPutUrl: vi.fn(),
			generatePresignedGetUrl: vi.fn(),
		};

		mockSummaryRepository = {
			save: vi.fn(),
		};

		mockMarkdownService = {
			parse: vi.fn(),
		};

		mockPromptService = {
			loadPrompt: vi.fn(),
		};

		// Create mock WorkflowStep
		mockStep = {
			do: vi.fn(async (_name, _config, fn) => {
				return await fn();
			}),
			sleep: vi.fn(),
			sleepUntil: vi.fn(),
		} as unknown as WorkflowStep;

		// Create handler instance
		handler = new SummarizeClassWorkflowHandler(
			mockProcessingService,
			mockAIService,
			mockStorageService,
			mockStorageRepository,
			mockSummaryRepository,
			mockMarkdownService,
			mockPromptService,
			"temporal-bucket",
		);
	});

	describe("run", () => {
		it("should process audio file successfully", async () => {
			// Arrange
			const mockPayload: WorkflowRequestBody = {
				classId: "class-123",
				userId: "user-456",
				input: {
					r2Key: "temp/user-456/audio.mp3",
					mimeType: "audio/mpeg",
					filename: "audio.mp3",
				},
			};

			const mockEvent = {
				payload: mockPayload,
				timestamp: new Date(),
			} as WorkflowEvent<WorkflowRequestBody>;

			const mockPrompt = "Test prompt";
			const mockFileUrl =
				"https://bucket.r2.example.com/temp/user-456/audio.mp3?signed";
			const mockSummaryMarkdown = "# Test Summary\n\nContent here";
			const mockSummaryHtml = "<h1>Test Summary</h1><p>Content here</p>";

			(
				mockPromptService.loadPrompt as ReturnType<typeof vi.fn>
			).mockResolvedValue(mockPrompt);
			(
				mockStorageRepository.generatePresignedGetUrl as ReturnType<
					typeof vi.fn
				>
			).mockResolvedValue(mockFileUrl);
			(
				mockAIService.generateSummaryFromUrl as ReturnType<typeof vi.fn>
			).mockResolvedValue(mockSummaryMarkdown);
			(mockMarkdownService.parse as ReturnType<typeof vi.fn>).mockReturnValue(
				mockSummaryHtml,
			);

			// Act
			await handler.run(mockEvent, mockStep);

			// Assert
			expect(
				mockStorageRepository.generatePresignedGetUrl,
			).toHaveBeenCalledWith("temporal-bucket", "temp/user-456/audio.mp3", 300);
			expect(mockPromptService.loadPrompt).toHaveBeenCalled();
			expect(mockAIService.generateSummaryFromUrl).toHaveBeenCalledWith(
				mockPrompt,
				mockFileUrl,
				"audio/mpeg",
			);
			expect(mockMarkdownService.parse).toHaveBeenCalledWith(
				mockSummaryMarkdown,
			);
			expect(mockSummaryRepository.save).toHaveBeenCalledWith(
				"class-123",
				"user-456",
				mockSummaryHtml,
			);
			expect(mockStorageService.deleteFile).toHaveBeenCalledWith(
				"temp/user-456/audio.mp3",
			);
		});

		it("should process text file successfully", async () => {
			// Arrange
			const mockPayload: WorkflowRequestBody = {
				classId: "class-123",
				userId: "user-456",
				input: {
					r2Key: "temp/user-456/notes.txt",
					mimeType: "text/plain",
					filename: "notes.txt",
				},
			};

			const mockEvent = {
				payload: mockPayload,
				timestamp: new Date(),
			} as WorkflowEvent<WorkflowRequestBody>;

			const mockPrompt = "Test prompt";
			const mockFileUrl =
				"https://bucket.r2.example.com/temp/user-456/notes.txt?signed";
			const mockSummaryMarkdown = "# Summary";
			const mockSummaryHtml = "<h1>Summary</h1>";

			(
				mockPromptService.loadPrompt as ReturnType<typeof vi.fn>
			).mockResolvedValue(mockPrompt);
			(
				mockStorageRepository.generatePresignedGetUrl as ReturnType<
					typeof vi.fn
				>
			).mockResolvedValue(mockFileUrl);
			(
				mockAIService.generateSummaryFromUrl as ReturnType<typeof vi.fn>
			).mockResolvedValue(mockSummaryMarkdown);
			(mockMarkdownService.parse as ReturnType<typeof vi.fn>).mockReturnValue(
				mockSummaryHtml,
			);

			// Act
			await handler.run(mockEvent, mockStep);

			// Assert
			expect(mockAIService.generateSummaryFromUrl).toHaveBeenCalledWith(
				mockPrompt,
				mockFileUrl,
				"text/plain",
			);
		});

		it("should throw error when AI service returns empty response", async () => {
			// Arrange
			const mockPayload: WorkflowRequestBody = {
				classId: "class-123",
				userId: "user-456",
				input: {
					r2Key: "temp/user-456/audio.mp3",
					mimeType: "audio/mpeg",
					filename: "audio.mp3",
				},
			};

			const mockEvent = {
				payload: mockPayload,
				timestamp: new Date(),
			} as WorkflowEvent<WorkflowRequestBody>;

			const mockPrompt = "Test prompt";
			const mockFileUrl =
				"https://bucket.r2.example.com/temp/user-456/audio.mp3?signed";

			(
				mockPromptService.loadPrompt as ReturnType<typeof vi.fn>
			).mockResolvedValue(mockPrompt);
			(
				mockStorageRepository.generatePresignedGetUrl as ReturnType<
					typeof vi.fn
				>
			).mockResolvedValue(mockFileUrl);
			(
				mockAIService.generateSummaryFromUrl as ReturnType<typeof vi.fn>
			).mockResolvedValue(""); // Empty response

			// Act & Assert
			await expect(handler.run(mockEvent, mockStep)).rejects.toThrow(
				"AI service returned empty response",
			);
		});

		it("should execute all four workflow steps", async () => {
			// Arrange
			const mockPayload: WorkflowRequestBody = {
				classId: "class-123",
				userId: "user-456",
				input: {
					r2Key: "temp/user-456/audio.mp3",
					mimeType: "audio/mpeg",
					filename: "audio.mp3",
				},
			};

			const mockEvent = {
				payload: mockPayload,
				timestamp: new Date(),
			} as WorkflowEvent<WorkflowRequestBody>;

			const mockFileUrl =
				"https://bucket.r2.example.com/temp/user-456/audio.mp3?signed";

			(
				mockPromptService.loadPrompt as ReturnType<typeof vi.fn>
			).mockResolvedValue("Test prompt");
			(
				mockStorageRepository.generatePresignedGetUrl as ReturnType<
					typeof vi.fn
				>
			).mockResolvedValue(mockFileUrl);
			(
				mockAIService.generateSummaryFromUrl as ReturnType<typeof vi.fn>
			).mockResolvedValue("# Summary\n\nTest");
			(mockMarkdownService.parse as ReturnType<typeof vi.fn>).mockReturnValue(
				"<h1>Summary</h1>",
			);

			// Act
			await handler.run(mockEvent, mockStep);

			// Assert
			expect(mockStep.do).toHaveBeenCalledTimes(4);
			expect(mockStep.do).toHaveBeenNthCalledWith(
				1,
				"prepare-file-input",
				expect.any(Object),
				expect.any(Function),
			);
			expect(mockStep.do).toHaveBeenNthCalledWith(
				2,
				"generate-summary",
				expect.any(Object),
				expect.any(Function),
			);
			expect(mockStep.do).toHaveBeenNthCalledWith(
				3,
				"save-summary",
				expect.any(Object),
				expect.any(Function),
			);
			expect(mockStep.do).toHaveBeenNthCalledWith(
				4,
				"cleanup-temp-file",
				expect.any(Object),
				expect.any(Function),
			);
		});
	});
});

```

D:\Humans\classmate\server\api\src\workflows\summarize-class\handler.ts
```typescript
import type { WorkflowEvent, WorkflowStep } from "cloudflare:workers";
import type { StorageRepository } from "../../domain/repositories/storage.repository";
import type { SummaryRepository } from "../../domain/repositories/summary.repository";
import type { AIService } from "../../domain/services/ai.service";
import type { MarkdownService } from "../../domain/services/markdown.service";
import type { ProcessingService } from "../../domain/services/processing.service";
import type { PromptService } from "../../domain/services/prompt.service";
import type { StorageService } from "../../domain/services/storage.service";
import { FileValidator } from "./file-validator";
import {
	type FileInput,
	PREPARE_FILE_INPUT_CONFIG,
	SAVE_SUMMARY_CONFIG,
	WORKFLOW_CONFIG,
	type WorkflowRequestBody,
} from "./types";

/**
 * Summarize Class Workflow Handler
 * Orchestrates the workflow steps for generating class summaries from audio/text files
 */
export class SummarizeClassWorkflowHandler {
	private fileValidator: FileValidator;

	constructor(
		private processingService: ProcessingService,
		private aiService: AIService,
		private storageService: StorageService,
		private storageRepository: StorageRepository,
		private summaryRepository: SummaryRepository,
		private markdownService: MarkdownService,
		private promptService: PromptService,
		private r2TemporalBucketName: string,
	) {
		this.fileValidator = new FileValidator();
	}

	async run(
		event: WorkflowEvent<WorkflowRequestBody>,
		step: WorkflowStep,
	): Promise<void> {
		const payload = event.payload;

		// Step 0: Prepare file input - convert URL to R2 file if needed
		const fileInput = await step.do(
			"prepare-file-input",
			PREPARE_FILE_INPUT_CONFIG,
			async () => {
				return await this.prepareFileInput(payload);
			},
		);

		// Step 1: Generate summary from file content
		const summaryMarkdown = await step.do(
			"generate-summary",
			WORKFLOW_CONFIG,
			async () => {
				return await this.generateSummary(payload.classId, fileInput);
			},
		);

		// Step 2: Convert markdown to HTML and save to database
		await step.do("save-summary", SAVE_SUMMARY_CONFIG, async () => {
			await this.saveSummary(payload, summaryMarkdown);
		});

		// Step 3: Cleanup - delete temporary file from R2
		await step.do("cleanup-temp-file", { timeout: "5 minutes" }, async () => {
			await this.cleanupTempFile(fileInput);
		});
	}

	private async prepareFileInput(
		payload: WorkflowRequestBody,
	): Promise<FileInput> {
		const { input, userId, classId } = payload;

		// Check if input is a URL (needs processing) or already an R2 file
		if ("sourceUrl" in input) {
			console.log("üîÑ [WORKFLOW] Processing URL input", {
				classId,
				sourceUrl: input.sourceUrl,
				timestamp: new Date().toISOString(),
			});

			// Delegate heavy processing to Cloud Run service
			const fileInput = await this.processingService.processUrl(
				input.sourceUrl,
				userId,
				classId,
			);

			console.log("‚úÖ [WORKFLOW] URL processed successfully", {
				classId,
				r2Key: fileInput.r2Key,
			});

			return fileInput;
		}

		// Input is already an R2 file, pass through
		console.log("‚úÖ [WORKFLOW] Using pre-uploaded R2 file", {
			classId,
			r2Key: input.r2Key,
		});

		return input;
	}

	private async generateSummary(
		classId: string,
		file: FileInput,
	): Promise<string> {
		const { mimeType, filename, r2Key } = file;

		const isAudioFile = this.fileValidator.isAudioFile(mimeType, filename);
		const audioMimeType = this.fileValidator.getAudioMimeType(
			mimeType,
			filename,
		);

		console.log("üì• [WORKFLOW] Generating summary", {
			classId,
			r2Key,
			isAudio: isAudioFile,
			timestamp: new Date().toISOString(),
		});

		// Load prompt template
		const prompt = await this.promptService.loadPrompt();

		// Generate presigned GET URL for the file (5 minutes expiration)
		const fileUrl = await this.storageRepository.generatePresignedGetUrl(
			this.r2TemporalBucketName,
			r2Key,
			300, // 5 minutes
		);

		console.log("üîó [WORKFLOW] Generated presigned URL for file", {
			classId,
			r2Key,
			urlLength: fileUrl.length,
		});

		// Pass URL directly to AI service - Gemini will download the file
		const summary = await this.aiService.generateSummaryFromUrl(
			prompt,
			fileUrl,
			isAudioFile ? audioMimeType : "text/plain",
		);

		if (!summary || typeof summary !== "string") {
			throw new Error("AI service returned empty response");
		}

		console.log("‚úÖ [WORKFLOW] Summary generated successfully", {
			classId,
			summaryLength: summary.length,
		});

		return summary;
	}

	private async saveSummary(
		payload: WorkflowRequestBody,
		summaryMarkdown: string,
	): Promise<void> {
		const { classId, userId } = payload;

		// Convert markdown to HTML
		const htmlSummary = this.markdownService.parse(summaryMarkdown);

		console.log("üîÑ [WORKFLOW] Converted markdown to HTML", {
			originalLength: summaryMarkdown.length,
			convertedLength: htmlSummary.length,
			classId,
		});

		// Save to database
		await this.summaryRepository.save(classId, userId, htmlSummary);

		console.log("‚úÖ [WORKFLOW] Summary saved to database", { classId });
	}

	private async cleanupTempFile(file: FileInput): Promise<void> {
		console.log("üóëÔ∏è [WORKFLOW] Cleaning up temporary file", {
			r2Key: file.r2Key,
		});

		await this.storageService.deleteFile(file.r2Key);

		console.log("‚úÖ [WORKFLOW] Temporary file deleted", {
			r2Key: file.r2Key,
		});
	}
}

```

D:\Humans\classmate\server\api\src\workflows\summarize-class\index.ts
```typescript
import {
	WorkflowEntrypoint,
	type WorkflowEvent,
	type WorkflowStep,
} from "cloudflare:workers";
import type { Bindings } from "../../config/bindings";
import { createSummarizeClassWorkflowHandler } from "./dependencies";
import type { WorkflowRequestBody } from "./types";

/**
 * Summarize Class Workflow Entrypoint
 * Cloudflare Workflow that processes audio/text files and generates class summaries
 */
export class SummarizeClassWorkflow extends WorkflowEntrypoint<
	Bindings,
	WorkflowRequestBody
> {
	async run(
		event: WorkflowEvent<WorkflowRequestBody>,
		step: WorkflowStep,
	): Promise<void> {
		console.log("üöÄ [WORKFLOW] Starting SummarizeClassWorkflow", {
			classId: event.payload.classId,
			userId: event.payload.userId,
			timestamp: event.timestamp,
		});

		// Create handler with dependency injection
		const handler = await createSummarizeClassWorkflowHandler(this.env);

		// Execute workflow
		await handler.run(event, step);

		console.log("‚úÖ [WORKFLOW] SummarizeClassWorkflow completed successfully", {
			classId: event.payload.classId,
		});
	}
}

```

D:\Humans\classmate\server\api\src\workflows\summarize-class\types.ts
```typescript
/**
 * Workflow Request Types
 */

export interface FileInput {
	r2Key: string;
	mimeType: string;
	filename: string;
}

export interface UrlInput {
	sourceUrl: string;
}

export interface WorkflowRequestBody {
	classId: string;
	userId: string;
	input: FileInput | UrlInput;
}

/**
 * Workflow Configuration
 */
export const PREPARE_FILE_INPUT_CONFIG = {
	retries: { limit: 3, delay: "10 seconds", backoff: "exponential" as const },
	timeout: "15 minutes",
} as const;

export const WORKFLOW_CONFIG = {
	retries: { limit: 3, delay: "10 seconds", backoff: "exponential" as const },
	timeout: "30 minutes",
} as const;

export const SAVE_SUMMARY_CONFIG = {
	retries: { limit: 5, delay: "5 seconds", backoff: "exponential" as const },
	timeout: "10 minutes",
} as const;

```
