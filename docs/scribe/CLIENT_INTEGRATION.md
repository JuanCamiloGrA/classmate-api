# Scribe Engine: Client Integration Guide

This document outlines the workflow for integrating the Scribe Engine into the client application. The Scribe Engine is an AI-powered document generation system that creates professional academic papers from rubrics and user input.

## Workflow Overview

The process consists of three distinct phases:
1.  **Rubric Upload**: The user provides the assignment requirements (file or text).
2.  **Dynamic Form**: The user answers specific questions generated by the AI to gather necessary context.
3.  **PDF Generation & Iteration**: The user reviews the generated document and iterates with the AI to refine it.

---

## Phase 1: Rubric Upload

**Goal**: Initialize a project and provide the context for the AI Architect.

### UI Requirements
- **Mandatory Rubric**: The user **must** provide a rubric.
- **Input Methods**:
    - **File Upload**: Support for PDF, images (PNG, JPEG, WebP, GIF), or text files.
    - **Manual Entry**: A "No rubric? Write one manually" toggle that shows a text area for copy-pasting or typing instructions.
- **Visuals**: Full-screen experience.

### Supported File Types
| Type | MIME Type |
| :--- | :--- |
| PDF | `application/pdf` |
| PNG | `image/png` |
| JPEG | `image/jpeg` |
| WebP | `image/webp` |
| GIF | `image/gif` |
| Plain Text | `text/plain` |
| Markdown | `text/markdown` |

### API Interaction

#### Option A: File Upload Flow (Recommended)

**1. Get Presigned Upload URL**
Before creating the project, get a presigned URL to upload the rubric file directly to storage.

```http
POST /scribe/upload-url
Content-Type: application/json

{
  "fileName": "rubric.pdf",
  "contentType": "application/pdf"
}
```

**Response (200 OK):**
```json
{
  "signedUrl": "https://...",
  "key": "scribe/rubrics/user-id/1234567890-rubric.pdf",
  "publicUrl": "https://..."
}
```

**2. Upload File to Storage**
Upload the file directly to R2 using the `signedUrl` (PUT request).

```http
PUT {signedUrl}
Content-Type: application/pdf

<binary file content>
```

**3. Create Project with File Reference**
```http
POST /scribe
Content-Type: application/json

{
  "rubricFileUrl": "https://...", // The publicUrl from step 1
  "rubricMimeType": "application/pdf",
  "title": "My History Essay", // Optional
  "subjectId": "subject-uuid", // Optional
  "taskId": "task-uuid" // Optional
}
```

#### Option B: Text Content Flow

For manual text entry or copy-paste:

```http
POST /scribe
Content-Type: application/json

{
  "rubricContent": "Your rubric text here...",
  "title": "My History Essay", // Optional
  "subjectId": "subject-uuid", // Optional
  "taskId": "task-uuid" // Optional
}
```

**Response (201 Created):**
The backend will create the project and trigger the **Architect Agent**. The project status will initially be `draft`.

```json
{
  "id": "project-uuid",
  "status": "draft",
  "rubricContent": "...",
  "rubricFileUrl": "...",
  "rubricMimeType": "...",
  ...
}
```

**4. Poll for Status**
The Architect Agent runs in the background (Cloudflare Workflow). Poll the project endpoint until the status changes to `collecting_answers`.

```http
GET /scribe/{project-uuid}
```

**Target State:**
```json
{
  "id": "project-uuid",
  "status": "collecting_answers",
  "formQuestions": { ... } // The JSON for Phase 2
}
```

---

## Phase 2: Dynamic Form

**Goal**: Gather specific knowledge from the student based on the rubric analysis.

### UI Requirements
- **Dynamic Rendering**: Render a form based on the `formQuestions` JSON returned in Phase 1.
- **Component Types**:
    - `select`: Dropdowns for tones, topics, methodologies.
    - `text_input`: Short answers (dates, names).
    - `textarea`: Long answers (anecdotes, arguments).
    - `checkbox`: Multiple selections.

### Data Structure (`formQuestions`)

The `formQuestions` field in the project response will follow this structure:

```json
{
  "form_title": "Essay Context & Strategy",
  "estimated_time": "5 minutes",
  "sections": [
    {
      "section_title": "Introduction & Context",
      "questions": [
        {
          "id": "q1",
          "type": "select",
          "label": "What is the desired tone?",
          "helper_text": "Choose the academic level.",
          "options": ["Formal", "Persuasive", "Narrative"]
        },
        {
          "id": "q2",
          "type": "textarea",
          "label": "Briefly describe your main argument.",
          "helper_text": "Don't worry about grammar, just get the idea down."
        }
      ]
    }
  ]
}
```

### API Interaction

**Submit Answers**
Collect the user's answers into a JSON object (key = question ID, value = answer) and send a `PUT` request.

```http
PUT /scribe/{project-uuid}
Content-Type: application/json

{
  "userAnswers": {
    "q1": "Formal",
    "q2": "The industrial revolution was..."
  }
}
```

**Response (200 OK):**
The backend will trigger the **Ghostwriter Agent**. The status will change to `drafting`.

---

## Phase 3: PDF Generation & Iteration

**Goal**: Review the generated document and refine it via chat.

### UI Requirements
- **Split Screen Layout**:
    - **Left (50%)**: PDF Preview (Rendered from the generated content).
    - **Right (50%)**: AI Chat Interface.
- **Visuals**: Floating card/container style for each half.

### API Interaction

**1. Poll for Content**
After submitting answers, poll the project endpoint until status becomes `reviewing` or `typesetting`.

```http
GET /scribe/{project-uuid}
```

**Target State:**
```json
{
  "id": "project-uuid",
  "status": "reviewing", // or 'typesetting' / 'completed'
  "contentMarkdown": "# Generated Content...", // Raw Markdown
  "currentLatex": "...", // If available
  "reviewFeedback": null
}
```

**2. Iteration (Chat)**
If the user wants changes (e.g., "Expand point 3", "Fix spelling"), send the feedback via `PUT`.

```http
PUT /scribe/{project-uuid}
Content-Type: application/json

{
  "reviewFeedback": {
    "message": "Please expand on the economic impacts in section 2.",
    "approved": false
  }
}
```

**Response:**
The backend triggers the **Supervisor Agent** to refine the content. Status goes back to `drafting` -> `reviewing`.

**3. Final Approval**
When the user is satisfied, they click "Download Final PDF". You can signal completion to the backend (optional, depending on flow) or just use the final content.

To finalize the workflow explicitly:

```http
PUT /scribe/{project-uuid}
Content-Type: application/json

{
  "reviewFeedback": {
    "approved": true
  }
}
```

This triggers the **Typesetter Agent** to generate the final LaTeX/PDF structure (status `typesetting` -> `completed`).

---

## Summary of Statuses

| Status | Description | Client Action |
| :--- | :--- | :--- |
| `draft` | Project created, Architect analyzing rubric. | Show loading / "Analyzing Rubric..." |
| `collecting_answers` | Architect finished. Questions ready. | **Render Phase 2 Form**. |
| `drafting` | Ghostwriter generating content. | Show loading / "Writing Draft..." |
| `reviewing` | Content generated. Ready for review. | **Render Phase 3 Split Screen**. |
| `typesetting` | Final formatting in progress. | Show loading / "Finalizing PDF..." |
| `completed` | Final document ready. | Show Download button. |
| `failed` | Something went wrong. | Show error message. |

---

## Summary of Endpoints

| Method | Endpoint | Description |
| :--- | :--- | :--- |
| `POST` | `/scribe/upload-url` | Generate presigned URL for rubric file upload |
| `POST` | `/scribe` | Create a new Scribe project |
| `GET` | `/scribe` | List all user's Scribe projects |
| `GET` | `/scribe/{id}` | Get a specific project |
| `PUT` | `/scribe/{id}` | Update project (answers, feedback) |
