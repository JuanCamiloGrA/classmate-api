# Scribe Engine: Client Integration Guide

This document outlines the workflow for integrating the Scribe Engine into the client application. The Scribe Engine is an AI-powered document generation system that creates professional academic papers from rubrics and user input.

## Workflow Overview

The process consists of three distinct phases:
1.  **Rubric Upload**: The user provides the assignment requirements (file or text).
2.  **Dynamic Form**: The user answers specific questions generated by the AI to gather necessary context.
3.  **PDF Output**: The user receives a presigned URL to view/download the final PDF document.

> **⚠️ Important**: The client **never sees markdown or Typst**. These are used internally between AI agents. The client only interacts with forms (`formQuestions`) and the final PDF URL (`finalPdfUrl`).

### Simplified Client Flow

```
1. User uploads rubric
2. Poll until status = "collecting_answers"
3. User answers form questions
4. Poll until:
   - status = "collecting_answers" (with NEW questions) → Go back to step 3
   - status = "completed" (with PDF URL) → Done!
5. Client displays/downloads PDF
```

The intermediate states (`drafting`, `reviewing`, `typesetting`) are internal and can be used only for loading indicators.

---

## Phase 1: Rubric Upload

**Goal**: Initialize a project and provide the context for the AI Architect.

### UI Requirements
- **Mandatory Rubric**: The user **must** provide a rubric.
- **Input Methods**:
    - **File Upload**: Support for PDF, images (PNG, JPEG, WebP, GIF), or text files.
    - **Manual Entry**: A "No rubric? Write one manually" toggle that shows a text area for copy-pasting or typing instructions.
- **Visuals**: Full-screen experience.

### Supported File Types
| Type | MIME Type |
| :--- | :--- |
| PDF | `application/pdf` |
| PNG | `image/png` |
| JPEG | `image/jpeg` |
| WebP | `image/webp` |
| GIF | `image/gif` |
| Plain Text | `text/plain` |
| Markdown | `text/markdown` |

### API Interaction

#### Option A: File Upload Flow (Recommended)

**1. Get Presigned Upload URL**
Before creating the project, get a presigned URL to upload the rubric file directly to storage.

```http
POST /scribe/upload-url
Content-Type: application/json

{
  "fileName": "rubric.pdf",
  "contentType": "application/pdf"
}
```

**Response (200 OK):**
```json
{
  "signedUrl": "https://...",
  "key": "scribe/rubrics/user-id/1234567890-rubric.pdf",
  "publicUrl": "https://..."
}
```

**2. Upload File to Storage**
Upload the file directly to R2 using the `signedUrl` (PUT request).

```http
PUT {signedUrl}
Content-Type: application/pdf

<binary file content>
```

**3. Create Project with File Reference**
```http
POST /scribe
Content-Type: application/json

{
  "rubricFileUrl": "https://...", // The publicUrl from step 1
  "rubricMimeType": "application/pdf",
  "templateId": "apa", // Optional, defaults to "apa". Options: "apa", "ieee", etc.
  "title": "My History Essay", // Optional
  "subjectId": "subject-uuid", // Optional
  "taskId": "task-uuid" // Optional
}
```

#### Option B: Text Content Flow

For manual text entry or copy-paste:

```http
POST /scribe
Content-Type: application/json

{
  "rubricContent": "Your rubric text here...",
  "templateId": "apa", // Optional, defaults to "apa". Options: "apa", "ieee", etc.
  "title": "My History Essay", // Optional
  "subjectId": "subject-uuid", // Optional
  "taskId": "task-uuid" // Optional
}
```

**Response (201 Created):**
The backend will create the project and trigger the **Architect Agent**. The project status will initially be `draft`.

```json
{
  "id": "project-uuid",
  "status": "draft",
  "templateId": "apa",
  "rubricContent": "...",
  "rubricFileUrl": "...",
  "rubricMimeType": "...",
  "formQuestions": null,
  "userAnswers": null,
  "finalPdfUrl": null,
  "reviewFeedback": null
}
```

> **Note**: The response does **not** include `contentMarkdown`, `currentTypstJson`, or `finalPdfFileId`. These fields are internal-only and excluded from all API responses.

**4. Poll for Status**
The Architect Agent runs in the background (Cloudflare Workflow). Poll the project endpoint until the status changes to `collecting_answers`.

```http
GET /scribe/{project-uuid}
```

**Target State:**
```json
{
  "id": "project-uuid",
  "status": "collecting_answers",
  "formQuestions": { ... } // The JSON for Phase 2
}
```

---

## Phase 2: Dynamic Form

**Goal**: Gather specific knowledge from the student based on the rubric analysis.

### UI Requirements
- **Dynamic Rendering**: Render a form based on the `formQuestions` JSON returned in Phase 1.
- **Component Types**:
    - `select`: Dropdowns for tones, topics, methodologies.
    - `text_input`: Short answers (dates, names).
    - `textarea`: Long answers (anecdotes, arguments).
    - `checkbox`: Multiple selections.
- **Revision Handling**: This phase may repeat if the AI Supervisor determines more information is needed.

### Data Structure (`formQuestions`)

The `formQuestions` field in the project response will follow this structure:

```json
{
  "form_title": "Essay Context & Strategy",
  "estimated_time": "5 minutes",
  "sections": [
    {
      "section_title": "Introduction & Context",
      "questions": [
        {
          "id": "q1",
          "type": "select",
          "label": "What is the desired tone?",
          "helper_text": "Choose the academic level.",
          "options": ["Formal", "Persuasive", "Narrative"]
        },
        {
          "id": "q2",
          "type": "textarea",
          "label": "Briefly describe your main argument.",
          "helper_text": "Don't worry about grammar, just get the idea down."
        }
      ]
    }
  ]
}
```

### Revision Form (Subsequent Rounds)

If the Supervisor Agent rejects the draft, the user will receive a new form with clarification questions:

```json
{
  "form_title": "Additional Information Needed",
  "estimated_time": "5 minutes",
  "sections": [
    {
      "section_title": "Clarifications",
      "questions": [
        {
          "id": "missing_citation_1",
          "type": "text_input",
          "label": "Please provide the source/URL for the claim: '80% of users...'",
          "context_snippet": "In paragraph 3, you stated..."
        }
      ]
    }
  ]
}
```

The `reviewFeedback` field will contain context about why revision is needed:
```json
{
  "status": "REVISION",
  "feedback_summary": "A statistic was mentioned without a source citation."
}
```

### API Interaction

**Submit Answers**
Collect the user's answers into a JSON object (key = question ID, value = answer) and send a `PUT` request.

```http
PUT /scribe/{project-uuid}
Content-Type: application/json

{
  "userAnswers": {
    "q1": "Formal",
    "q2": "The industrial revolution was..."
  }
}
```

**Response (200 OK):**
The backend will trigger the **Ghostwriter Agent** → **Supervisor Agent** pipeline. The status will change through `drafting` → `reviewing` automatically.

> **Note**: Answers are **accumulated** across rounds. The backend structures them internally as `_initialAnswers` and `_revisionAnswers[]`. You don't need to manage this—just send the new answers each time.

---

## Phase 3: Result Polling

**Goal**: Wait for AI processing to complete and receive either more questions or the final PDF.

### UI Requirements
- **Loading States**: Show appropriate loading messages during processing.
- **Two Possible Outcomes**:
    1. **More Questions**: `status = "collecting_answers"` with new `formQuestions` → Go back to Phase 2
    2. **Completed**: `status = "completed"` with `finalPdfUrl` → Display/download the PDF

### API Interaction

**Poll for Result**
After submitting answers, poll the project endpoint until status becomes `collecting_answers` (with new questions) or `completed`.

```http
GET /scribe/{project-uuid}
```

**Outcome A: Revision Needed**
```json
{
  "id": "project-uuid",
  "status": "collecting_answers",
  "formQuestions": {
    "form_title": "Additional Information Needed",
    "sections": [...]
  },
  "reviewFeedback": {
    "status": "REVISION",
    "feedback_summary": "..."
  },
  "finalPdfUrl": null
}
```
→ **Action**: Render the new form (Phase 2 again)

**Outcome B: Completed**
```json
{
  "id": "project-uuid",
  "status": "completed",
  "formQuestions": {...},
  "finalPdfUrl": "https://r2-presigned-url.../generated-pdfs/user_xxx/2025/11/document.pdf?signature=...",
  "reviewFeedback": {
    "approved": true
  }
}
```
→ **Action**: Display or download the PDF

### Displaying the PDF

The `finalPdfUrl` field contains a **presigned URL** to the generated PDF document. This URL is valid for **7 days** from generation.

Options for displaying:
- **Embed**: Use an `<iframe>` or PDF viewer component to display inline
- **New Tab**: Open the URL directly in a new browser tab
- **Download**: Provide a download button that opens the URL

```typescript
// Example: Open PDF in new tab
window.open(project.finalPdfUrl, '_blank');

// Example: Embed in iframe
<iframe src={project.finalPdfUrl} width="100%" height="600px" />
```

> **Note**: The URL expires after 7 days. If the user needs to access the PDF later, they should download it or the client can request a fresh URL by fetching the project again (a new presigned URL will be generated).

---

## Summary of Statuses

| Status | Description | Client Action |
| :--- | :--- | :--- |
| `draft` | Project created, Architect analyzing rubric. | Show loading / "Analyzing Rubric..." |
| `collecting_answers` | Questions ready (initial or revision). | **Render Form (Phase 2)**. Check `reviewFeedback` for context. |
| `drafting` | Ghostwriter generating content. | Show loading / "Writing Draft..." |
| `reviewing` | Supervisor reviewing content. | Show loading / "Reviewing..." |
| `typesetting` | Final formatting and PDF generation in progress. | Show loading / "Generating PDF..." |
| `completed` | Final PDF ready. | **Display PDF / Show Download**. |
| `failed` | Something went wrong. | Show error message. |

### Key Decision Points

```typescript
if (status === "collecting_answers") {
  // Check if this is initial or revision
  if (reviewFeedback?.status === "REVISION") {
    // Show revision context to user
    showMessage(reviewFeedback.feedback_summary);
  }
  // Render formQuestions
  renderForm(formQuestions);
}

if (status === "completed") {
  // Display final PDF
  displayPdf(finalPdfUrl);
  // Or open in new tab
  // window.open(finalPdfUrl, '_blank');
}
```

---

## Summary of Endpoints

| Method | Endpoint | Description |
| :--- | :--- | :--- |
| `POST` | `/scribe/upload-url` | Generate presigned URL for rubric file upload |
| `POST` | `/scribe` | Create a new Scribe project |
| `GET` | `/scribe` | List all user's Scribe projects |
| `GET` | `/scribe/{id}` | Get a specific project (excludes `contentMarkdown`) |
| `PUT` | `/scribe/{id}` | Update project (answers only—no manual review feedback) |

---

## Response Schema

All endpoints return projects **without** internal fields:

```typescript
interface ScribeProjectResponse {
  id: string;
  userId: string;
  templateId: string; // Template used for PDF generation (e.g., "apa", "ieee")
  title: string;
  status: "draft" | "collecting_answers" | "drafting" | "reviewing" | "typesetting" | "completed" | "failed";
  rubricContent: string | null;
  rubricFileUrl: string | null;
  rubricMimeType: string | null;
  formQuestions: FormQuestions | null;
  userAnswers: Record<string, unknown> | null;
  // contentMarkdown is EXCLUDED - internal use only
  // currentTypstJson is EXCLUDED - internal use only
  // finalPdfFileId is EXCLUDED - internal use only
  finalPdfUrl: string | null; // Presigned URL to PDF (valid 7 days)
  reviewFeedback: ReviewFeedback | null;
  subjectId: string | null;
  taskId: string | null;
  createdAt: string;
  updatedAt: string;
}
```

### URL Expiration

The `finalPdfUrl` is a presigned URL valid for **7 days**. After expiration:
- The PDF still exists in storage
- Fetching the project again (`GET /scribe/{id}`) will return a fresh presigned URL
- Consider caching the PDF locally if long-term access is needed
