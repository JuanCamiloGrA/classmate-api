import { z } from "zod";

/**
 * Scribe Agents Configuration
 *
 * Each agent has:
 * - model: The AI model identifier (via Vercel AI Gateway)
 * - promptPath: Path to the system prompt template in ASSETS
 * - outputSchema: Optional Zod schema for structured output (generateObject)
 */

// ============================================================================
// Output Schemas
// ============================================================================

/**
 * Schema for a single form question generated by the Architect Agent
 */
const FormQuestionSchema = z.object({
	id: z.string().describe("Unique identifier for the question"),
	type: z
		.enum(["select", "text_input", "textarea", "checkbox"])
		.describe("UI component type"),
	label: z.string().describe("The user-facing question text"),
	helper_text: z
		.string()
		.optional()
		.describe("Optional context to help answer the question"),
	options: z
		.array(z.string())
		.optional()
		.describe("Options for select or checkbox types"),
});

/**
 * Schema for a section of questions
 */
const FormSectionSchema = z.object({
	section_title: z.string().describe("Title for the section"),
	questions: z.array(FormQuestionSchema).describe("Questions in this section"),
});

/**
 * Complete output schema for the Architect Agent
 */
export const ArchitectOutputSchema = z.object({
	form_title: z.string().describe("Title for the form UI header"),
	estimated_time: z.string().describe("Estimated time to complete the form"),
	sections: z.array(FormSectionSchema).describe("Form sections with questions"),
});

export type ArchitectOutput = z.infer<typeof ArchitectOutputSchema>;

// ============================================================================
// Typesetter Output Schema
// ============================================================================

/**
 * Output schema for the Typesetter Agent
 * Contains metadata for PDF cover page and LaTeX body content
 */
export const TypesetterOutputSchema = z.object({
	title: z
		.string()
		.describe("Document title extracted from the heading or metadata"),
	course: z
		.string()
		.describe("Course name if mentioned, otherwise 'Academic Document'"),
	student: z
		.string()
		.describe("Student name if mentioned, otherwise 'Student'"),
	date: z
		.string()
		.describe("Date in format 'DD of Month, YYYY' (e.g., 'November 25, 2025')"),
	latex_content: z
		.string()
		.describe(
			"LaTeX body content starting with \\section{} - NO preamble or document wrapper",
		),
});

export type TypesetterOutput = z.infer<typeof TypesetterOutputSchema>;

// ============================================================================
// Agent Configurations
// ============================================================================

export interface ScribeAgentConfig {
	/** AI model identifier for Vercel AI Gateway (e.g., "google/gemini-2.5-flash-lite") */
	model: string;
	/** Path to system prompt template in ASSETS (e.g., "scribe/prompt-01-architect.txt") */
	promptPath: string;
	/** Optional Zod schema for structured output */
	outputSchema?: z.ZodType;
	/** Description of what this agent does */
	description: string;
}

/**
 * Agent config with required outputSchema for structured output agents
 */
export interface ScribeAgentWithSchema extends ScribeAgentConfig {
	outputSchema: z.ZodType;
}

/**
 * Architect Agent Configuration
 *
 * Analyzes rubric (PDF/text) and generates dynamic form questions.
 * Uses structured output (generateObject) to ensure valid JSON response.
 */
export const ARCHITECT_AGENT: ScribeAgentWithSchema = {
	model: "openai/gpt-5-nano",
	promptPath: "scribe/prompt-01-architect.txt",
	outputSchema: ArchitectOutputSchema,
	description:
		"Analyzes rubric and generates form questions for user input collection",
};

/**
 * Ghostwriter Agent Configuration
 *
 * Generates the document content in Markdown based on rubric and user answers.
 * Uses text generation (generateText) for free-form Markdown output.
 */
export const GHOSTWRITER_AGENT: ScribeAgentConfig = {
	model: "openai/gpt-5-mini",
	promptPath: "scribe/prompt-02-ghostwriter.txt",
	description:
		"Generates academic document content in Markdown from rubric and user answers",
};

/**
 * Supervisor Agent Configuration
 *
 * Reviews generated content against rubric requirements.
 * Can approve for typesetting or request revisions with follow-up questions.
 */
export const SUPERVISOR_AGENT: ScribeAgentConfig = {
	model: "openai/gpt-5-nano",
	promptPath: "scribe/prompt-03-supervisor.txt",
	description:
		"Reviews generated content and either approves or requests revisions",
};

/**
 * Typesetter Agent Configuration
 *
 * Converts final Markdown content to LaTeX format with extracted metadata.
 * Uses structured output (generateObject) to ensure valid JSON response.
 */
export const TYPESETTER_AGENT: ScribeAgentWithSchema = {
	model: "groq/gpt-oss-120b",
	promptPath: "scribe/prompt-04-typesetter.txt",
	outputSchema: TypesetterOutputSchema,
	description:
		"Converts approved Markdown content to structured JSON with metadata and LaTeX body",
};

// ============================================================================
// Supported MIME Types for Rubric Files
// ============================================================================

/**
 * Supported MIME types for rubric file uploads
 * These are the formats that Gemini models can process directly
 */
export const SUPPORTED_RUBRIC_MIME_TYPES = [
	"application/pdf",
	"image/png",
	"image/jpeg",
	"image/webp",
	"image/gif",
	"text/plain",
	"text/markdown",
] as const;

export type SupportedRubricMimeType =
	(typeof SUPPORTED_RUBRIC_MIME_TYPES)[number];

/**
 * Check if a MIME type is supported for rubric files
 */
export function isSupportedRubricMimeType(
	mimeType: string,
): mimeType is SupportedRubricMimeType {
	return SUPPORTED_RUBRIC_MIME_TYPES.includes(
		mimeType as SupportedRubricMimeType,
	);
}
